# 1. Api специфікація

## Яка різниця між PUT і PATCH запитом?

Різниця між запитами PUT і PATCH відображається в тому, як сервер обробляє об’єкт, щоб змінити ресурс, 
ідентифікований за допомогою Request-URI. PUT запит містить об’єкт, що вважається модифікованою версією ресурсу,
який зберігається на сервері, і клієнт просить замінити збережену версію. В PATCH вкладений об’єкт 
містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на вихідному сервері, повинен бути змінений 
для створення нової версії. Метод PATCH МОЖЕ мати побічні ефекти на інші ресурси; тобто нові ресурси можуть бути 
створені або змінені існуючі за допомогою застосування виправлення.

PATCH МОЖЕ створити новий ресурс залежно від типу patch документу.

PATCH описує набір змін в «patch документі», що визначається за допомогою media-type. Хоча явно ніде не написано, але
в загальному випадку application/json - не являється patch документом. Адже сервер ніяк не зможе зрозуміти яким чином
йому змінювати ресурс.

Patch документ зазвичай може приймати одну з двох форм:

- Містити чіткий опис змін. Приклад [json-patch](https://datatracker.ietf.org/doc/html/rfc6902/)

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch
```json
[
  { "op": "replace", "path": "/title", "value": "First article!" },
  { "op": "add", "path": "/tags", "value": ["sample"] },
  { "op": "remove", "path": "/author" }
]
```

The result

```json
{
  "title": "First article!",
  "tags": ["example", "sample"],
  "content": "My article."
}
```

- Містити модифіковану версію ресурсу і дозволити серверу самому визначити набір змін. Приклад [json/merge-patch](https://datatracker.ietf.org/doc/html/rfc7396)

The original document
```json
{
  "baz": "qux",
  "foo": "bar",
  "name": "fred"
}
```

The patch
```json5
{
  "title": "First article!", // { "op": "replace", "path": "/title", "value": "First article!" }
  "hello": ["world"], // { "op": "replace", "path": "/hello", "value": ["world"] }
  "foo": null // { "op": "remove", "path": "/foo" }
}
```

The result

```json
{
  "baz": "boo",
  "hello": ["world"],
  "name": "fred"
}
```

Мінус json-merge-patch в тому що він не може описати нормально описати деякі операції: наприклад додавання елементу 
в массив.


Мені здається ми можемо зробити свій rollun-json-patch з меншим набіром операції ніж в json-patch. Або підтримувати
обидва варіанти. 

## Як виконувати версіонування API?

Версіонування api залишаємо в url, це дозволить простіше кешувати ресурси (адже uri однозначно співвідноситься з даними
які повертаються), а також дозволить вказувати версію при відправці get запиту через браузер.

В маніфесті будем застосовувати семантичне версіонування. Це дозволить, при мінорних змінах, серверам розуміти що в них 
імплементується не остання версія і її потрібно обновити.

```yaml
openapi: "3.0.0"
info:
  title: petShop
  description: API exposing my pet shop’s functionality
  version: "2.1.2"
servers:
  - url: https://example.org/petShop/v2
```

Можливий підхід як в [gcloud](https://www.belgif.be/specification/rest/api-guide/#api-versioning), коли в url міститься
тільки мажорна версія, тобто сервер завжди підтримує одну мінорну і патч версію. Це дозволить залишити простоту в 
реалізації серверу. І можливо ніяк не буде впливати на клієнта, якому важлива тільки мажорна версія. Це стане 
зрозумілішим коли розпишемо співвідношення між змінами в API та версією.

## Як повертати історію виконання лонг-таску?

Історія може повертатись окремим http запитом.

## Як працюють рейт ліміти?

## Чи потрібно використовувати теги в openapi маніфесті?

## Чи можна засобами http реалізувати часткове отримання ресурсу?

## Як оброблювати помилку виконання лонг таску?

## Чи потрібен нам власний медіа тип?

## Як передавати lifecycle_token?

## Що повинні повертати запити, якщо лонг-таск видалено?

## Яка інформація повинна передаватись в messages?

# 2. Openapi генератор

## Як повинен працювати вибір сервера?

## Як повинна працювати авторизація?

## Як реалізувати підтримку oneOf?

## План впровадження нових можливостей по версіям

### Версія 1

### Версія 2

### Версія 3

- Кешування інкапсульоване клієнтом