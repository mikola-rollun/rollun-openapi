# 1. Api специфікація

## Яка різниця між PUT і PATCH запитом?

Різниця між запитами PUT і PATCH відображається в тому, як сервер обробляє об’єкт, щоб змінити ресурс, 
ідентифікований за допомогою Request-URI. PUT запит містить об’єкт, що вважається модифікованою версією ресурсу,
який зберігається на сервері, і клієнт просить замінити збережену версію. В PATCH вкладений об’єкт 
містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на вихідному сервері, повинен бути змінений 
для створення нової версії. Метод PATCH МОЖЕ мати побічні ефекти на інші ресурси; тобто нові ресурси можуть бути 
створені або змінені існуючі за допомогою застосування виправлення.

PATCH МОЖЕ створити новий ресурс залежно від типу patch документу.

PATCH описує набір змін в «patch документі», що визначається за допомогою media-type. Хоча явно ніде не написано, але
в загальному випадку application/json - не являється patch документом. Адже сервер ніяк не зможе зрозуміти яким чином
йому змінювати ресурс.

Patch документ зазвичай може приймати одну з двох форм:

- Містити чіткий опис змін. Приклад [json-patch](https://datatracker.ietf.org/doc/html/rfc6902/)

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch
```json
[
  { "op": "replace", "path": "/title", "value": "First article!" },
  { "op": "add", "path": "/tags", "value": ["sample"] },
  { "op": "remove", "path": "/author" }
]
```

The result

```json
{
  "title": "First article!",
  "tags": ["example", "sample"],
  "content": "My article."
}
```

- Містити модифіковану версію ресурсу і дозволити серверу самому визначити набір змін. Приклад [json/merge-patch](https://datatracker.ietf.org/doc/html/rfc7396)

The original document
```json
{
  "baz": "qux",
  "foo": "bar",
  "name": "fred"
}
```

The patch
```json5
{
  "title": "First article!", // { "op": "replace", "path": "/title", "value": "First article!" }
  "hello": ["world"], // { "op": "replace", "path": "/hello", "value": ["world"] }
  "foo": null // { "op": "remove", "path": "/foo" }
}
```

The result

```json
{
  "baz": "boo",
  "hello": ["world"],
  "name": "fred"
}
```

Мінус json-merge-patch в тому що він не може описати нормально описати деякі операції: наприклад додавання елементу 
в массив.


Мені здається ми можемо зробити свій rollun-json-patch з меншим набіром операції ніж в json-patch. Або підтримувати
обидва варіанти. 

## Як виконувати версіонування API?

## Як повертати історію виконання лонг-таску?

Історія може повертатись окремим http запитом.

## Як працюють рейт ліміти?

## Чи потрібно використовувати теги в openapi маніфесті?

## Чи можна засобами http реалізувати часткове отримання ресурсу?

## Як оброблювати помилку виконання лонг таску?

## Чи потрібен нам власний медіа тип?

## Як передавати lifecycle_token?

## Що повинні повертати запити, якщо лонг-таск видалено?

## Яка інформація повинна передаватись в messages?

# 2. Openapi генератор

## Як повинен працювати вибір сервера?

## Як повинна працювати авторизація?

## Як реалізувати підтримку oneOf?

## План впровадження нових можливостей по версіям

### Версія 1

### Версія 2

### Версія 3

- Кешування інкапсульоване клієнтом