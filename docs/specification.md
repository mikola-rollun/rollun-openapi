# Визначення

## Клієнт і сервер

Поняття з клієнт-серверної архітектури. У загальному випадку це дві програми які можуть обмінюватись інформацією 
(зазвичай через інтернет мережу).

Сервер - відповідає за збереження інформації й надає клієнтам інтерфейс для її отримання, модифікації чи збереження.
Також інтерфейс може надавати клієнту функції для виконання функцій (на виконання обчислень, чи бізнес дій).

## Ресурс

Головною абстракцією в REST є ресурс. *Ресурс - будь-яка інформація, якій можна дати ім'я*. Наприклад документ (зображення),
сутність(замовлення, стаття, людина), колекція інших ресурсів, динамічне значення (погода у Львові) і т.п.

*Ресурс має стан*, що зберігається сервером. Клієнт може отримувати, або змінювати стан ресурсу за допомогою представлень.

*Представлення - це дані ресурсу в певному форматі*: JSON/XML/HTML/текст. Один ресурс може мати багато представлень.
Наприклад зображення - це ресурс, а JPEG, WEBM та інші формати - його представлення.

## URI

Для того щоб модифікувати ресурс нам потрібно якимось чином вказати який саме ресурс ми хочемо модифікувати, тобто
ідентифікувати його. Для цього використовується URI - Uniform Resource Identifier. Про URI можна думати як про рядок з
іменем, або псевдонімом ресурсу.

URL - найбільш відомий стандарт URI для ідентифікації ресурсів в інтернеті. URL - окремий випадок URI, конкретна його
реалізація.

# Стилі проєктування

Для зручності визначення подальших правил потрібно розділити два підходи до проєктування API: REST і PRC.

## REST

REST підхід розглядає ресурси як сутності, над якими можна виконувати операції за допомогою HTTP методів. 

Наприклад в системі електронної комерції можуть бути сутності: замовлення і клієнти. Створення замовлення відбувається
відправкою POST запиту з відомостями про замовлення, а відповідь буде містити інформацію про результат розміщення 
замовлення. Зчитування всіх замовлень клієнта відправкою GET запиту. Детальніше про операції описано в розділі
[операції над ресурсами](#операції-над-ресурсами).

Ресурс не обов'язково повинен точно відповідати сутностям в коді, або базі даних. Наприклад ресурс замовлення може бути 
реалізований з використанням декількох таблиць в базі даних, але використовуватись клієнтом як єдина сутність.

Це рекомендований підхід до проєктування API, який слід, за можливості, використовувати.

## RPC

RPC виклики розглядають ресурс як контроллер, що може запускати, повертати стан і контролювати якусь дію. Це може 
бути корисним, якщо нам потрібно надати клієнту можливість одним викликом виконувати бізнес дію над декількома
ресурсами, або розтягнуту у часі.

Наприклад для відеохостингу нам може знадобитись конвертувати відео з одного формату в інший. В такому випадку ми
можемо створити ресурс-контролер /video/{id}/actions/convert. Процес конвертації запускається POST запитом з відомостями про 
формати в які потрібно виконати конвертацію, відповідь вкаже на вдачність запуску дії. GET запит поверне інформацію
про виконання конвертації: статус, результат (якщо є), час завершення, кількість виконаних відсотків і т.п.

У випадках, якщо дія виконується швидко, то ми можемо залишити лише POST запит, який відразу поверне результат. 
Це може використовуватись для описання бізнес дій, які виконують транзакцію над декількома сутностями. Наприклад
переведення грошей з рахунку одного клієнта, на рахунок іншого.

# Іменування

## Спільні правила іменування

Для назви ресурсу **ПОВИНЕН** використовуватись kebab-case. Тобто усі символи в нижньому регістрі, а слова розділені
дефісом.

```
https://site.com/ordered-items // Good

https://site.com/orderedItems // Avoid
```

Для позначення ієрархічних відносин **ПОВИНЕН** використовуватись символ `/`.

```
https://site.com/customers/1/orders
https://site.com/customers/1/orders/99/items
```

**Рекомендується** використовувати не більше двух рівней вкладеності. URL **ПОВИНЕН** містити менше трьох рівней 
вкладеності.

Наприклад ```/customers/1/orders/99/items``` краще розділити на ```/customers/1/orders``` та ```orders/99/items```. 
Це пов'язано з тим що довгі ієрархії залежностей важче читати та змінювати у разі зміни зв'язків між ресурсами.

## Іменування у REST стилі

В REST стилі назва ресурсу **ПОВИННА** бути іменником.

```
https://site.com/orders // Good

https://site.com/create-order // Avoid
```

В URL ресурс **ПОВИНЕН** бути вказаним у множині. Це забезпечує зручне розмежування виконання дій над ресурсом 
сінглтоном і колекцією. Так ```GET /customers``` повертає відомості про колекцію з усіма клієнтами, а 
```GET /customers/{id}``` повертає інформацію про одного клієнта з ідентифікатором `{id}`. 

```
https://site.com/orders // Good

https://site.com/order // Avoid
```

## Іменування у RPC стилі

Ресурс у RPC стилі **ПОВИНЕН** бути дієсловом. Також він **ПОВИНЕН** бути вкладеним у колекцію `/actions`. 

```
https://site.com/video/1/actions/convert // Good

https://site.com/video/1/convert // Avoid
https://site.com/video/1/actions/converter // Avoid
```

# Операції над ресурсами

## REST

Для виконання операції над ресурсом використовуються http методи. Нижче описані найпоширеніші http методи, якими 
обходиться переважна більшість REST API:

- **GET**. Повертає представлення ресурсу за вказаним універсальним ідентифікатором ресурсу (URI). Відповідь містить 
текст з відомостями про запитаний ресурс.
- **POST**. Створює новий ресурс за вказаним URI. Текст запиту містить відомості про новий ресурс.
- **PUT**. Створює або замінює ресурси за вказаним URI. У тексті повідомлення запиту вказано відомості про ресурс, що 
створюється або оновлюється.
- **PATCH**. Виконує часткове оновлення ресурсу. Текст запиту визначає набір змін, які застосовуються до ресурсу.
- **DELETE**. Видаляє ресурс за вказаним URI.

Результат запиту залежить від того чи ресурс, над яким виконується дія, є колекцією, чи окремим елементом.

| Ресурс              | 	POST	                                     | GET	                                | PUT	                                         | DELETE                              |
|---------------------|--------------------------------------------|-------------------------------------|----------------------------------------------|-------------------------------------|
| /customers          | 	Створення нового клієнта                  | 	Отримання колекції всіх клієнтів	  | Масове оновлення клієнтів                    | 	Видалення всіх клієнтів            |
| /customers/1        | 	Помилка                                   | 	Отримання відомостей про клієнта 1 | 	Створює або замінює відомості про клієнта 1 | 	Видалення клієнта 1                |
| /customers/1/orders | 	Створення нового замовлення для клієнта 1 | 	Отримання всіх замовлень клієнта 1 | 	Масове оновлення замовлень клієнта 1        | 	Видалення всіх замовлень клієнта 1 |

## RPC

У випадку RPC ресурс є бізнес-дією (операцією, контроллером), а не сутністю, що спричиняє деякі відмінності. 
Найпоширеніші http методи, що використовується в RPC стилі:

- **POST** - використовується для старту операції. Текст запиту містить інформацію потрібну для виконання операції. 
Відповідь містить інформацію про вдачність початку виконання операції, або її результат.
- **GET** - повертає відомості про стан виконання операції.

| Ресурс                       | 	POST	                       | GET	                                                                        |
|------------------------------|------------------------------|-----------------------------------------------------------------------------|
 | /video/1/actions/convert     | 	Початок конвертації відео 1 | 	Повертає колекцію усіх задач по конвертації відео 1	                       |
 | /video/1/actions/convert/a2b | 	Помилка                     | 	Повертає інформацію про задачу конвертації відео 1 з ідентифікатором 'a2b' |

## Ідемпотентність

В специфікації http усі методи, окрім POST - є ідемпотентними. Це означає, що виконання методу кілька разів поспіль з 
однаковими параметрами приводить до однакового результату. Для клієнта це означає, що він може безпечно повторити запит,
якщо не отримав відповіді від сервера.

Ця специфікація додає додаткове обмеження: POST **ПОВИНЕН** бути ідемпотентним за допомогою механізму описаного [нижче](#POST).

Розглянемо що це означає на практиці для кожного методу.

### GET

GET - не повинен виконувати ніяких дії над ресурсом, він лише повертає стан ресурсу у конкретний момент часу. Це означає,
що ми можемо безпечно виконувати будь-яку кількість GET запитів до ресурсу і це не змінить його стан. 

Важливо зазначити, що стан ресурсу може змінюватись сам по собі, або внаслідок запитів від інших клієнтів. Тому два GET 
запити, виконані один за одним, можуть повернути різний стан ресурсу. Це не є порушенням ідемпотентності, адже стан 
ресурсу не внаслідок GET запиту.

### POST

Як згадувалось раніше в http специфікації POST - не ідемпотентний. Це означає, що два однакових POST запита створять два однакових ресурса.
У цих ресурсів можуть відрізнятись ідентифікатори, якщо ідентифікатор генерується серверною стороною, а не передається
від клієнта у запиті, разом з іншими відомостями про ресурс.

Оскільки взаємодія через мережу є ненадійною і дані можуть втрачатись, то може виникнути ситуація, коли клієнт надіслав
POST запит і не отримав відповіді від сервера. У цьому випадку клієнт ніяк не може дізнатись який з двух випадків
відбувся:

1. Запит від клієнта не дійшов до сервера і ресурс не був створений.
2. Запит дійшов до сервера і ресурс був створений, але відповідь від сервера не дійшла до клієнта.

Тобто фактично, надіславши POST запит і не отримавши відповіді клієнт не знає чи ресурс був створений. Повторно 
надіслати ще один POST - небезпечно, оскільки може створитись дублікат ресурсу.

Для того, щоб розв'язувати проблему описану вище POST запит роблять ідемпотентним. Для цього клієнт до ресурсу додає 
'idempotencyKey', який має бути однаковим для двух однакових ресурсів. Сервер, коли отримує POST запит перевіряє, чи
існує ресурс з переданим 'idempotencyKey', якщо ні - то створює його, якщо так, то не створює новий, а повертає у 
відповіді вже створений. Таким чином клієнт може у разі чого повторно надіслати POST запит і не хвилюватись, що 
буде створений дублікат ресурсу.

### PUT та PATCH

TODO

### DELETE

DELETE являється ідемпотентним оскільки не важливо скільки запитів на видалення ресурсу ми відправимо - у результаті
ресурс буде видаленим. 

Якщо відправити два однакових DELETE запита, то перший видалить ресурс, а другий нічого не 
зробить, але у результаті зо після першого, що після другого запиту ресурс залишиться видаленим.

# Структура представлення ресурсу

## Представлення ресурсу у відповіді на запит

Кожне представлення ресурсу у відповіді повинен наслідувати поля від openapi компонента ErrorResponse - якщо виникла 
помилка, SuccessResponse - для успішної відповіді.

```yaml
ErrorResponse:
    type: object
    properties:
        messages:
            type: array
            items:
                $ref: "#/components/schemas/Message"
            description: 
    description: >
        Список повідомлень про виконання запиту: помилки, попередження, або інша корисна для клієнта інформація.
Message:
    type: object
    properties:
        level:
            type: string
            enum: [`emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info`]
        type:
            type: string
            enum:
                - UNDEFINED
            description: >
                Тип повідомлення для зручного розрізняння помилки клієнтською програмою.
                Назви типів повинні бути у верхньому регістрі, а слова розділені нижнім 
                підкреслюванням '_' (e.g. VALIDATION_ERROR).
                UNDEFINED - тип за замовчуванням
        text:
            type: string
            description: довільний текст з поясненням для людини
SuccessResponse:
    allOf:
        - $ref: '#/components/schemas/ErrorResponse'
    type: object
    properties:
        data:
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

У відповіді **ПОВИННО** бути присутнім одне з полів: 'data', або 'messages'.

> Компоненти вище описані для openapi специфікації версії '3.0.0'. Згідно якої, якщо не вказано, що поле обов'язкове
> (його немає у масиві required), то цей ключ може бути відсутній у компоненті. Тобто у специфікації вище фактично
> дозволяється повернути пусту відповідь ('{}'). Тому ми накладаємо додаткові обмеження.

Якщо у відповіді відсутній ключ `data` (або його значення null), то у messages **РЕКОМЕНДУЄТЬСЯ** наявність, як мінімум, 
одного повідомлення з `level` рівним `error` або вище.

> Рівні сортируются у порядку спадання наступним чином: `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, 
> `info`

> Фактично за схемою поле 'data' не може мати значення null, але через помилку у старих версіях php генератора немає 
> можливості зовсім не повернути поле 'data' і воно повертається зі значенням 'null'. Після того як усі програми 
> перейдуть на нову версію генератора і виправлять помилку, то умову про 'null' можна буде прибрати зі специфікації.

```json5
{
  "messages": [
    // оскільки `data` відсутня, то хоча б одна помилка (повідомлення з рівнем 'error' або вище) повинна бути присутня
    {
      "type": "VALIDATION_ERROR",
      "level": "error",
      "text": "Track number has wrong format."
    }
  ]
}
```

Якщо `data` і `messages` одночасно присутні у відповіді, то `messages` **НЕ ПОВИНЕН** містити повідомлень з рівнем вище
ніж warning.

```json5
{
  "data": {
    "id": "...",
    "trackNumber": "...",
    "shippingMethod": "FedEx 2Day",
    "estimateDeliveryDate": null
  },
  "messages": [
    {
      "type": "NO_SHIPPING_ESTIMATES",
      "level": "warning",
      // не може бути error тому що `data` не пуста 
      "text": "No rules found to calculate estimates for 'FedEx 2Day'."
    }
  ]
}
```

## Наявність ідентифікатора

При використанні REST стилю серед корисних даних ресурсу перелічених у 'data' **ПОВИННО** бути поле з ідентифікатором. 
За замовчуванням назва поля `id`. Це потрібно для однозначної ідентифікації кожного окремого елементу з колекції, а 
також його кешування.

Наприклад нам потрібно виводити на сайті інформацію про кількість оформлених замовлень на різних маркетплейсах за певний 
період часу. Для цього ми можемо використати ресурс `/statistcs/created_orders` в query якого вказувати період. В такому 
випадку ідентифікатором може бути об'єднання інформації про приналежність статистики до певного маркетплейса, і періоду
за який надається статистика.

```http request
GET /statistcs/created_orders?from=2022-05-18T12:00:00Z&to=2022-05-18T13:00:00Z

// Response
{ 
 "data": { 
   [
     "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Ebay",
     "created_orders": 25 
   ],
   [
     "id": "Amazon | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Amazon",
     "created_orders": 10 
   ]
 } 
}
```

```http request
GET /statistcs/created_orders/Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z

// Response
{ 
 "data": { 
   "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
   "marketplace": "Ebay",
   "created_orders": 25 
 } 
}
```


## Представлення ресурсу запиту для POST, PUT, PATCH методів

Тіло запиту повинно наслідуватись від openapi компонента RequestBody.

```yaml
RequestBody:
  type: object
  required:
    - data
  properties:
    data:
      type: object
  description: Корисна інформація про ресурс. Тобто усі поля які описують стан ресурсу.

  ```http request
```

Приклад запиту на створення статті. 

```http request
POST /articles
Content-Type: application/json
Accept: application/json

{
  "data": {
    "title": "New article",
    "imgUrl": "http://example.com/images/new_article.png"
  }
}
```

# Long running tasks

Якщо запит виконується тривалий проміжок часу (хвилину і більше), то добре рішення оформити його як long running task.

## Структура

Long running task це [ресурс](#ресурс), який **ПОВИНЕН** містити наступні ключі:

- `id` - ідентифікатор, який генерується на стороні серверу.
- `status` - enum: [`pending`, `fullfilled`, `rejected`]
- `data` - данні необхідні для створення [ресурсу](#ресурс)
- `result` - об'єкт, що наслідується від ErrorResponse або SuccessResponse

Якщо задача зі статусом `pending`, то `result` **ПОВИНЕН** бути null

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
    "data": {
      "title": "...",
      "content": "..."
    },
    "result": null
  }
}
```

Якщо задача зі статусом `fulfilled`, то `result` **ПОВИНЕН** містити `data`.

```json5
{
  "data": {
    "id": "12345",
    "status": "fulfilled",
    "data": {
      "title": "...",
      "content": "..."
    },
    "result": {
      "data": {
        "article_id": '4352'
      }
    }
  }
}
```

Якщо задача зі статусом `rejected`, то `result` **ПОВИНЕН** містити `messages` з хоча б одною помилкою.

```json5
{
  "data": {
    "id": "12345",
    "status": "rejected",
    "data": {
      "title": "...",
      "content": "..."
    },
    "result": {
      "data": null,
      "messages": [
        {
          "type": "VALIDATION_ERROR",
          "level": "error",
          "text": "Title contains invalid characters."
        }
      ]
    }
  }
}
```

Long running task **МОЖЕ** містити ключі:

- `idempotencyKey` - ключ ідемпотентності.
- `stage` - рядок з більш детальним (ніж в status) станом задачі.
- `startTime` - date-time: дата початку виконання задачі в UTC.
- `endTime` - date-time: дата закінчення виконання задачі в UTC.
- `timeout` - int: максимальний час виконання задачі в секундах, після якого її потрібно скасувати. Скасована задача 
потрапляє у статус rejected.

## Створення long running task

Якщо передано ключ ідемпотентності, то, з таким ключем, допускається наявність тільки однієї задачі зі статусом
fulfilled або pending. Зі статусом rejected може бути будь-яка кількість задач з однаковим ключем ідемпотентності.

Якщо задача з переданим в запиті ключем ідемпотентності вже існує, то потрібно повернути цю задачу у відповіді.

Наприклад поставимо задачу на створення статті:

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "data": {
      "title": "New article",
      "content": "A"
    }
  }
}
```

У відповідь отримуємо pending задачу з ідентифікатором 12345:

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
    "data": {
      "title": "New article",
      "content": "А"
    },
    "result": null
  }
}
```

У цей момент відправимо ще один ідентичний минулому запит

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "data": {
      "title": "New article",
      "content": "A"
    }
  }
}
```

Оскільки задача у статусі pending, то у відповідь отримуємо ту саму задачу з ідентифікатором 12345, а нової не
створиться:

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
    "data": {
      "title": "New article",
      "content": "А"
    },
    "result": null
  }
}
```

Через якийсь час перевіримо статус задачі

```http request
GET /articles/task/12345
```

Отримаємо rejected задачу, оскільки поле 'content' не пройшло валідацію.

```json5
{
  "data": {
    "id": "12345",
    "status": "rejected",
    "data": {
      "title": "New article",
      "content": "А"
    },
    "result": {
      "data": null,
      "messages": [
        {
          "type": "VALIDATION_ERROR",
          "level": "error",
          "text": "Content should contains at least 5 characters."
        }
      ]
    }
  }
}
```

Виправляємо content і повторюємо створення з тим самим ключем ідемпотентності

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "data": {
      "title": "New article",
      "content": "My first article!"
    }
  }
}
```

На сервері вже зберігається одна задача з ідентифікатором 12345 і ключем ідемпотентності 124. Але оскільки вона має
статус rejected, то сервер створює ще одну задачу з цим самим ключем ідемпотентності 124, але іншим ідентифікатором.

```json5
{
  "data": {
    "id": "54321",
    "status": "pending",
    "data": {
      "title": "New article",
      "content": "My first article!"
    },
    "result": null
  }
}
```

Через деякий час перевіряємо її статус

```http request
GET /articles/task/54321
```

І отримуємо задачу зі статусом fulfilled у якої в результаті є ідентифікатор створеної статті.

```json5
{
  "data": {
    "id": "54321",
    "status": "fulfilled",
    "data": {
      "title": "New article",
      "content": "My first article!"
    },
    "result": {
      "data": {
        "article_id": '1'
      }
    }
  }
}
```

За допомогою ідентифікатора можем отримати повну інформацію про статтю

```http request
GET /articles/1
```

```json
{
  "data": {
    "id": 1,
    "title": "New article",
    "content": "My first article!",
    "created_at": "..."
  }
}
```

## Скасування задачі

Задача **МОЖЕ** мати можливість бути скасованою декількома способами. 

1. Після закінчення таймауту (якщо такий був переданний). 
2. Посилання http - запиту. Поки без деталей як саме, але при необхідності потрібно їх уточнити і додати в специфікацію.

Після скасування задача потрапляє у rejected статус.
