# 1 Визначення

## 1.1 Клієнт і сервер

Поняття з клієнт-серверної архітектури. У загальному випадку це дві програми які можуть обмінюватись інформацією
(зазвичай через інтернет мережу).

Сервер - відповідає за збереження інформації й надає клієнтам інтерфейс для її отримання, модифікації чи збереження.
Також інтерфейс може надавати клієнту функції для виконання функцій (на виконання обчислень, чи бізнес дій).

## 1.2 Ресурс

Головною абстракцією в REST є ресурс. *Ресурс - будь-яка інформація, якій можна дати ім'я*. Наприклад документ (
зображення),
сутність(замовлення, стаття, людина), колекція інших ресурсів, динамічне значення (погода у Львові) і т.п.

*Ресурс має стан*, що зберігається сервером. Клієнт може отримувати, або змінювати стан ресурсу за допомогою
представлень.

*Представлення - це дані ресурсу в певному форматі*: JSON/XML/HTML/текст. Один ресурс може мати багато представлень.
Наприклад зображення - це ресурс, а JPEG, WEBM та інші формати - його представлення.

## 1.3 URI

Для того щоб модифікувати ресурс нам потрібно якимось чином вказати який саме ресурс ми хочемо модифікувати, тобто
ідентифікувати його. Для цього використовується URI - Uniform Resource Identifier. Про URI можна думати як про рядок з
іменем, або псевдонімом ресурсу.

URL - найбільш відомий стандарт URI для ідентифікації ресурсів в інтернеті. URL - окремий випадок URI, конкретна його
реалізація.

# 2 Підхід до проєктування

REST підхід розглядає ресурси як сутності, над якими можна виконувати операції за допомогою HTTP методів.

Наприклад в системі електронної комерції можуть бути сутності: замовлення і клієнти. Створення замовлення відбувається
відправкою POST запиту з відомостями про замовлення, а відповідь буде містити інформацію про результат розміщення
замовлення. Зчитування всіх замовлень клієнта відправкою GET запиту. Детальніше про операції описано в розділі
[операції над ресурсами](#4-операції-над-ресурсами).

Ресурс не обов'язково повинен точно відповідати сутностям в коді, або базі даних. Наприклад ресурс замовлення може бути
реалізований з використанням декількох таблиць в базі даних, але використовуватись клієнтом як єдина сутність.

Інколи нам потрібно надати клієнту можливість одним викликом виконувати складну бізнес-операцію над ресурсом, яку 
складно описати CRUD методами. Такі операції записуються в колекцію `actions` ресурсу. Де назва операції буде 
ідентифікатором елементу в колекції.

Наприклад 

```
// Конвертація відео з одного формату в інший
POST /video/{video_id}/actions/convert
{"data":{"to":["mpeg4", "webm"]}}

// Перевод грошей з одного рахунку на інший
/account/actions/transfer
{"data":{"from":"123", "to":"456"}}
```

# 3 Іменування

## 3.1 Спільні правила іменування

Для назви ресурсу **ПОВИНЕН** використовуватись kebab-case. Тобто усі символи в нижньому регістрі, а слова розділені
дефісом.

```
https://site.com/ordered-items // Good

https://site.com/orderedItems // Avoid
```

Для позначення ієрархічних відносин **ПОВИНЕН** використовуватись символ `/`.

```
https://site.com/customers/1/orders
https://site.com/customers/1/orders/99/items
```

**Рекомендується** використовувати не більше двух рівней вкладеності. URL **ПОВИНЕН** містити менше трьох рівней
вкладеності.

Наприклад ```/customers/1/orders/99/items``` краще розділити на ```/customers/1/orders``` та ```orders/99/items```.
Це пов'язано з тим що довгі ієрархії залежностей важче читати та змінювати у разі зміни зв'язків між ресурсами.

Назва ресурсу **ПОВИННА** бути іменником.

```
https://site.com/orders // Good

https://site.com/create-order // Avoid
```

В URL ресурс **ПОВИНЕН** бути вказаним у множині. Це забезпечує зручне розмежування виконання дій над ресурсом
сінглтоном і колекцією. Так ```GET /customers``` повертає відомості про колекцію з усіма клієнтами, а
```GET /customers/{id}``` повертає інформацію про одного клієнта з ідентифікатором `{id}`.

```
https://site.com/orders // Good

https://site.com/order // Avoid
```

## 3.2 Іменування екшенів

Формат url
```
{resource}/actions/{action_name}
```

Де `{resource}` - це ресурс-колекція (videos, orders), або конкретний елемент колекції (videos/1, orders/abc).
`{action_name}` - ідентифікатор (назва) операції, що **ПОВИНННА** бути дієсловом. В данному випадку `{action_name}`
сприймається як ідентифікатор елементу в колекції `actions`, саме тому він може бути дієсловом.

```
https://site.com/videos/1/actions/convert // Good

https://site.com/videos/1/actions/converter // Avoid
```

# 4 Операції над ресурсами

## 4.1 Загальні правила

Для виконання операції над ресурсом використовуються http методи. Нижче описані найпоширеніші http методи, якими
обходиться переважна більшість REST API:

- **GET**. Повертає представлення ресурсу за вказаним універсальним ідентифікатором ресурсу (URI). Відповідь містить
  текст з відомостями про запитаний ресурс.
- **POST**. Створює новий ресурс за вказаним URI. Текст запиту містить відомості про новий ресурс.
- **PUT**. Створює або замінює ресурси за вказаним URI. У тексті повідомлення запиту вказано відомості про ресурс, що
  створюється або оновлюється.
- **PATCH**. Виконує часткове оновлення ресурсу. Текст запиту визначає набір змін, які застосовуються до ресурсу.
- **DELETE**. Видаляє ресурс за вказаним URI.

Результат запиту залежить від того чи ресурс, над яким виконується дія, є колекцією, чи окремим елементом.

| Ресурс              |    POST                                         | GET                                    | PUT                                             | DELETE                              |
|---------------------|--------------------------------------------|-------------------------------------|----------------------------------------------|-------------------------------------|
| /customers          |    Створення нового клієнта                  |    Отримання колекції всіх клієнтів      | Масове оновлення клієнтів                    |    Видалення всіх клієнтів            |
| /customers/1        |    Помилка                                   |    Отримання відомостей про клієнта 1 |    Створює або замінює відомості про клієнта 1 |    Видалення клієнта 1                |
| /customers/1/orders |    Створення нового замовлення для клієнта 1 |    Отримання всіх замовлень клієнта 1 |    Масове оновлення замовлень клієнта 1        |    Видалення всіх замовлень клієнта 1 |

## 4.2 Actions

У данному випадку кожен елемент колекції 'actions' є також ресурсом-колекцією, що зберігає конкретні екземпляри
виконання операції. 

Опис методів, що використовуються над екземплярами колекції `actions`:

- **POST** - використовується для старту операції. Текст запиту містить інформацію потрібну для виконання операції.
  Відповідь містить інформацію про вдачність початку виконання операції, або її результат.
- **GET** - повертає відомості про стан виконання операції.

| Ресурс                       | POST                                                                                                             | GET                                                                        |
|------------------------------|------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| /video/1/actions             | Створити нову операцію (action). В данному випадку тіло, скоріш за все, буде містити код для виконання операції. | Отримати список усіх операції, що можна виконати над відео 1               |
| /video/1/actions/convert     | Почати конвертації відео 1. У відповіді може бути результат, або ресурс с ідентифікатором задачі.                | Повертає колекцію усіх екземплярів задач по конвертації відео 1            |
| /video/1/actions/convert/a2b | Помилка                                                                                                          | Повертає інформацію про задачу конвертації відео 1 з ідентифікатором 'a2b' |

## 4.3 Ідемпотентність

В специфікації http усі методи, окрім POST - є ідемпотентними. Це означає, що виконання методу кілька разів поспіль з
однаковими параметрами приводить до однакового результату. Для клієнта це означає, що він може безпечно повторити запит,
якщо не отримав відповіді від сервера.

Ця специфікація додає додаткове обмеження: POST **ПОВИНЕН** бути ідемпотентним за допомогою механізму
описаного [нижче](#POST).

Розглянемо що це означає на практиці для кожного методу.

### 4.3.1 GET

GET - не повинен виконувати ніяких дії над ресурсом, він лише повертає стан ресурсу у конкретний момент часу. Це
означає,
що ми можемо безпечно виконувати будь-яку кількість GET запитів до ресурсу і це не змінить його стан.

Важливо зазначити, що стан ресурсу може змінюватись сам по собі, або внаслідок запитів від інших клієнтів. Тому два GET
запити, виконані один за одним, можуть повернути різний стан ресурсу. Це не є порушенням ідемпотентності, адже стан
ресурсу не внаслідок GET запиту.

### 4.3.2 POST

Як згадувалось раніше в http специфікації POST - не ідемпотентний. Це означає, що два однакових POST запита створять два
однакових ресурса.
У цих ресурсів можуть відрізнятись ідентифікатори, якщо ідентифікатор генерується серверною стороною, а не передається
від клієнта у запиті, разом з іншими відомостями про ресурс.

Оскільки взаємодія через мережу є ненадійною і дані можуть втрачатись, то може виникнути ситуація, коли клієнт надіслав
POST запит і не отримав відповіді від сервера. У цьому випадку клієнт ніяк не може дізнатись який з двух випадків
відбувся:

1. Запит від клієнта не дійшов до сервера і ресурс не був створений.
2. Запит дійшов до сервера і ресурс був створений, але відповідь від сервера не дійшла до клієнта.

Тобто фактично, надіславши POST запит і не отримавши відповіді клієнт не знає чи ресурс був створений. Повторно
надіслати ще один POST - небезпечно, оскільки може створитись дублікат ресурсу.

Для того, щоб розв'язувати проблему описану вище POST запит роблять ідемпотентним. Для цього клієнт до ресурсу додає
'idempotencyKey', який має бути однаковим для двух однакових ресурсів. Сервер, коли отримує POST запит перевіряє, чи
існує ресурс з переданим 'idempotencyKey', якщо ні - то створює його, якщо так, то не створює новий, а повертає у
відповіді вже створений. Таким чином клієнт може у разі чого повторно надіслати POST запит і не хвилюватись, що
буде створений дублікат ресурсу.

### 4.3.3 PUT та PATCH

TODO

### 4.3.4 DELETE

DELETE являється ідемпотентним оскільки не важливо скільки запитів на видалення ресурсу ми відправимо - у результаті
ресурс буде видаленим.

Якщо відправити два однакових DELETE запита, то перший видалить ресурс, а другий нічого не
зробить, але у результаті зо після першого, що після другого запиту ресурс залишиться видаленим.

# 5. Структура представлення ресурсу

## 5.1 Представлення ресурсу у відповіді на запит

Кожне представлення ресурсу у відповіді повинен наслідувати поля від openapi компонента ErrorResponse - якщо виникла
помилка, SuccessResponse - для успішної відповіді.

```yaml
ErrorResponse:
    type: object
    properties:
        messages:
            type: array
            items:
                $ref: "#/components/schemas/Message"
            description:
    description: >
        Список повідомлень про виконання запиту: помилки, попередження, або інша корисна для клієнта інформація.
Message:
    type: object
    properties:
        level:
            type: string
            enum: [ `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info` ]
        type:
            type: string
            enum:
                - UNDEFINED
            description: >
                Тип повідомлення для зручного розрізняння помилки клієнтською програмою.
                Назви типів повинні бути у верхньому регістрі, а слова розділені нижнім 
                підкреслюванням '_' (e.g. VALIDATION_ERROR).
                UNDEFINED - тип за замовчуванням
        text:
            type: string
            description: довільний текст з поясненням для людини
SuccessResponse:
    allOf:
        -   $ref: '#/components/schemas/ErrorResponse'
    type: object
    properties:
        data:
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

> Поле 'data' фактично може бути якого завгодно типу, але генератор поки не підтримує поля у яких не об'явлений тип,
> тому зазвичай тип поля 'data' в маніфесті ставиться 'object'. Але він може бути змінений у об'єкті нащадку.
>```yaml
>SuccessResponse:
>  allOf:
>    - $ref: '#/components/schemas/ErrorResponse'
>  type: object
>  properties:
>    data:
>      type: object
>ResourceResponse:
>  allOf:
>    - $ref: '#/components/schemas/SuccessResult'
>  type: object
>  properties:
>    data:
>      type: string
>```

У відповіді **ПОВИННО** бути присутнім одне з полів: 'data', або 'messages'.

> Компоненти вище описані для openapi специфікації версії '3.0.0'. Згідно якої, якщо не вказано, що поле обов'язкове
> (його немає у масиві required), то цей ключ може бути відсутній у компоненті. Тобто у специфікації вище фактично
> дозволяється повернути пусту відповідь ('{}'). Тому ми накладаємо додаткові обмеження.

Якщо у відповіді відсутній ключ `data` (або його значення null), то у messages **РЕКОМЕНДУЄТЬСЯ** наявність, як мінімум,
одного повідомлення з `level` рівним `error` або вище.

> Рівні сортируются у порядку спадання наступним чином: `emergency`, `alert`, `critical`, `error`, `warning`, `notice`,
> `info`

> Фактично за схемою поле 'data' не може мати значення null, але через помилку у старих версіях php генератора немає
> можливості зовсім не повернути поле 'data' і воно повертається зі значенням 'null'. Після того як усі програми
> перейдуть на нову версію генератора і виправлять помилку, то умову про 'null' можна буде прибрати зі специфікації.

```json5
{
  "messages": [
    // оскільки `data` відсутня, то хоча б одна помилка (повідомлення з рівнем 'error' або вище) повинна бути присутня
    {
      "type": "VALIDATION_ERROR",
      "level": "error",
      "text": "Track number has wrong format."
    }
  ]
}
```

Якщо `data` і `messages` одночасно присутні у відповіді, то `messages` **НЕ ПОВИНЕН** містити повідомлень з рівнем вище
ніж warning.

```json5
{
  "data": {
    "id": "...",
    "trackNumber": "...",
    "shippingMethod": "FedEx 2Day",
    "estimateDeliveryDate": null
  },
  "messages": [
    {
      "type": "NO_SHIPPING_ESTIMATES",
      "level": "warning",
      // не може бути error тому що `data` не пуста 
      "text": "No rules found to calculate estimates for 'FedEx 2Day'."
    }
  ]
}
```

## 5.2 Наявність ідентифікатора

При використанні REST стилю серед корисних даних ресурсу перелічених у `data` **ПОВИННО** бути поле з ідентифікатором.
За замовчуванням назва поля `id`. Це потрібно для однозначної ідентифікації кожного окремого елементу з колекції, а
також його кешування.

Наприклад нам потрібно виводити на сайті інформацію про кількість оформлених замовлень на різних маркетплейсах за певний
період часу. Для цього ми можемо використати ресурс `/statistcs/created_orders` в query якого вказувати період. В такому
випадку ідентифікатором може бути об'єднання інформації про приналежність статистики до певного маркетплейса, і періоду
за який надається статистика.

```http request
GET /statistcs/created_orders?from=2022-05-18T12:00:00Z&to=2022-05-18T13:00:00Z

// Response
{ 
 "data": { 
   [
     "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Ebay",
     "created_orders": 25 
   ],
   [
     "id": "Amazon | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Amazon",
     "created_orders": 10 
   ]
 } 
}
```

```http request
GET /statistcs/created_orders/Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z

// Response
{ 
 "data": { 
   "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
   "marketplace": "Ebay",
   "created_orders": 25 
 } 
}
```

## 5.3 Представлення ресурсу запиту для POST, PUT, PATCH методів

Тіло запиту повинно наслідуватись від openapi компонента RequestBody.

```yaml
RequestBody:
    type: object
    required:
        - data
    properties:
        data:
            type: object
    description: Корисна інформація про ресурс. Тобто усі поля які описують стан ресурсу.

    ```http request
```

Приклад запиту на створення статті.

```http request
POST /articles
Content-Type: application/json
Accept: application/json

{
  "data": {
    "title": "New article",
    "imgUrl": "http://example.com/images/new_article.png"
  }
}
```

# 6 Використання статус кодів

## 6.1 Таблиця статус кодів

| Код | Назва                 | Опис                                                                                                                                                                  |
|-----|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 200 | OK                    | Під час виконання запиту не виникло будь-яких помилок (як бізнес логіки, так і серверу), що завадили б виконанню. Результат виконання присутній у відповіді.          |
| 202 | Accepted              | Запит принятий у опрацювання, але ще не виконано. У відповіді міститься ресурс або ідентифікатор екшену, за допомогою якого можна відстежувати стан виконання запиту. |
| 403 | Forbidden             | Запит коректний, але під час його виконання відбулась помилка бізнес логіки, через яку запит не виконався. Повторний ідентичний запит не змінить ситуацію.            |
| 500 | Internal Server Error | Під час виконання запиту відбулась помилка на сервері, через яку запит не виконався. Повторний ідентичний запит може успішно виконатись.                              |

## 6.2 Приклади використання

Для прикладу візьмемо API блогу, що дозволяє створювати та переглядати статті. Кожна стаття складається з 
ідентифікатора (`id`), заголовку (`title`) та змісту (`content`). 

### 6.1.1 Отримання усіх статей  

Для цього клієнт виконує наступний запит 

```http request
GET /articles
```

В данному випадку може повернутись або 200 або 500 код. 

Якщо повернувся код 200, то у відповіді також міститься список статей. 
```json5
{
  "data": [
    {
      "id": "1",
      "title": "Стаття 1",
      "content": "Зміст статті 1"
    },
    {
      "id": "2"
      // ...
    }
  ]
}
```

Якщо повернувся код 500, то відбулась помилка на сервері (не бізнес логіки), а відповідь містить лише інформацію про 
помилку. Наприклад, що база даних не доступна. Повторний запит може повернути успішний результат.

```json
{
  "messages": [
    {
      "type": "UNDEFINED",
      "level": "error",
      "text": "Database not available."
    }
  ]
}
```

### 6.2.2 Створення статті

Для створення статті клієнту достатньо передати `title` та `content`.

```http request
POST /articles
Content-Type: application/json

{
  "data" : {"title": "Hello, world!", "content": "My first article."}
}
```

У відповідь можуть повернутись коди: 200, 202, 403, 500.

Якщо повернувся код 200, то це означає, що стаття була успішно створена. Навіть якщо відбулись якісь не критичні 
помилки як, наприклад, не відправилось email сповіщення автору про створення нової статті.

```json5
{
  "data": {
    "id": "3",
    "title": "Hello, world!", 
    "content": "My first article."
  },
  "messages": [
    {
      "type": "UNDEFINED",
      "level": "warning",
      "text": "Email notification was not send."
    }
  ]
}
```

Якщо повернувся код 403, то це означає, що відбулась помилка бізнес-логіки, яка завадила створенню статті. Наприклад, 
якщо створення статті платне, а у користувача недостатньо коштів на балансі. 

```json5
{
  "messages": [
    {
      "type": "PAYMENT_ERROR",
      "level": "warning",
      "text": "Account has not enough money on balance."
    }
  ]
}
```

Якщо повернувся код 500, то це означає, що відбулась помилка сервера. Наприклад, при імплементації можливості створити
статтю програміст допустив якусь помилку, що спричиняє помилку виконання коду (runtime exception).

```json5
{
  "messages": [
    {
      "type": "UNDEFINED",
      "level": "warning",
      "text": "Server internal error."
    }
  ]
}
```

Якщо повернувся код 202, то це означає, що створення статті відбудеться асинхронно. Сервер в такому випадку повертає
ідентифікатор задачі (лонг таску), по якому можна відстежувати стан виконання запиту. Url за яким потрібно 
відстежувати виконання відомий завчасно (описаний у маніфесті).

```json5
{
  "data": {
    "task_id": "abc1",
  }
}
```

Припустимо що url за яким ми можем відстежити стан виконання запиту: `/articles/actions/post/{task_id}`

Лонг таск - це окремий випадок екшену (що буде детальніше описано [далі](#7-long-running-tasks)), тож
```GET /articles/actions/post/abc1``` запит може повернути коди: 200, 202, 403, 500. 

Код 403 і 500 повертається у ситуаціях аналогічних описаним вище. Просто вже як відповідь на GET, а не POST, запит.

Код 202 повертається, якщо виконання запиту ще в процесі. У тілі відповіді міститься інформація про стан виконання.

```json5
{
  "data": {
    "status": "pending",
    "stage": "validation"
  }
}
```

Код 200 повертається коли виконання запиту закінчилось успішно. Відповідь містить результат виконання, що у нашому
випадку є статтею. Аналогічно, як і у випадку синхронної задачі: при цьому могли відбутись не критичні помилки, що не
завадили створити статтю. 

```json5
{
  "data": {
    "id": "3",
    "title": "Hello, world!",
    "content": "My first article."
  },
  "messages": [
    {
      "type": "UNDEFINED",
      "level": "warning",
      "text": "Email notification was not send."
    }
  ]
}
```

# 7 Long-running tasks

Якщо запит виконується тривалий проміжок часу (хвилину і більше), то добре рішення оформити його як long-running task.

## Зв'язок з rpc actions

RPC actions схожі на long-running tasks тим, що також дозволяють асинхронно виконувати тривалу у часі дію, та 
слідкувати за станом її виконання. Головна відмінність полягає у тому як запускаються 

## Структура POST запиту

Post запит для long тасків наслідує усі правила описані в розділі ["Представлення ресурсу запиту для POST, PUT, PATCH
методів"ї(#представлення-ресурсу-запиту-для-post-put-patch-методів).

Для передачі даних необхідних для виконання задачу (фактично вхідних аргументів) **ПОВИННО** використовуватись поле
`payload`.

Приклад запиту на створення статті з певними `title` і `content`.

```json5
{
  "data": {
    "payload": {
      "title": "...",
      "content": "..."
    }
  }
}
```

### Ідемпотентність

Для забезпечення ідемпотентності POST запиту **МОЖЕ** використовуватись поле 'idempotencyKey'. При цьому в залежності
від того де ми розташуємо це поле може змінитись його сенс. Розглянемо на прикладі.

Якщо ми розташуємо поле `idempotencyKey` безпосередньо як частину об'єкта `data`, то воно буде відповідати за те, щоб
ідемпотентним було **створення задачі**. Наприклад відправивши декілька разів запит нижче ми створимо лише одну задачу
на створення статті.

```json5
{
  "data": {
    "idempotencyKey": "123",
    "payload": {
      "title": "Нова стаття!",
    }
  }
}
```

При цьому якщо ми відправимо запит вище, а потім змінимо значення `idempotencyKey`, наприклад на 124, і відправимо ще
раз. То створиться 2 різних задачі, обидві з яких створять статтю с `title` 'Нова стаття!'.

Тепер розглянемо інше місце для ключа ідемпотентності. Ми можемо його розмістити як частину об'єкту `payload`. Тоді
ідемпотентним буде **результат виконання задачі**. Наприклад відправивши декілька запитів нижче ми створимо декілька
різних задач, але все одно створиться лише одна стаття.

```json5
{
  "data": {
    "payload": {
      "idempotencyKey": "123",
      "title": "Нова стаття!",
    }
  }
}
```

## Структура відповіді

Long running task **ПОВИНЕН** містити наступні поля:

- `id` - ідентифікатор, який генерується на стороні серверу.
- `status` - enum: [`pending`, `fullfilled`, `rejected`]

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
  }
}
```

Long running task **МОЖЕ** містити ключі:

- `payload` - данні необхідні для виконання задачі (аналог вхідним аргументам функції)
- `result` - об'єкт, що наслідується від ErrorResponse або SuccessResponse
- `idempotencyKey` - ключ ідемпотентності.
- `stage` - рядок з більш детальним (ніж в status) станом задачі.
- `startTime` - date-time: дата початку виконання задачі в UTC.
- `endTime` - date-time: дата закінчення виконання задачі в UTC.
- `timeout` - int: максимальний час виконання задачі в секундах, після якого її потрібно скасувати. Скасована задача
  потрапляє у статус rejected.

### Приклади

Приклад створеної задачі, яка ще не виконалась.

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
  }
}
```

Приклад відповіді, якщо задача не смогла створитись (наприклад не доступна база даних).

```json5
{
  "messages": [
    {
      "type": "UNDEFINED",
      "level": "error",
      "text": "Server internal error."
    }
  ]
}
```

Приклад успішно виконанної задачі.

```json5
{
  "data": {
    "id": "12345",
    "status": "fulfilled",
    "result": {
      "data": {
        "article_id": '4352'
      }
    }
  }
}
```

Приклад задачі, виконання якої завершилась помилкою

```json5
{
  "data": {
    "id": "12345",
    "status": "rejected",
    "result": {
      "data": null,
      "messages": [
        {
          "type": "VALIDATION_ERROR",
          "level": "error",
          "text": "Title contains invalid characters."
        }
      ]
    }
  }
}
```

## Створення long running task

Якщо передано ключ ідемпотентності, то, з таким ключем, допускається наявність тільки однієї задачі зі статусом
fulfilled або pending. Зі статусом rejected може бути будь-яка кількість задач з однаковим ключем ідемпотентності.

Якщо задача з переданим в запиті ключем ідемпотентності вже існує, то потрібно повернути цю задачу у відповіді.

Наприклад поставимо задачу на створення статті:

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "payload": {
      "title": "New article",
      "content": "A"
    }
  }
}
```

У відповідь отримуємо pending задачу з ідентифікатором 12345:

```json5
{
  "data": {
    "id": "12345",
    "idempotency_key": "124",
    "status": "pending"
  }
}
```

У цей момент відправимо ще один ідентичний минулому запит

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "data": {
      "title": "New article",
      "content": "A"
    }
  }
}
```

Оскільки задача у статусі pending, то у відповідь отримуємо ту саму задачу з ідентифікатором 12345, а нової не
створиться:

```json5
{
  "data": {
    "id": "12345",
    "status": "pending",
    "data": {
      "title": "New article",
      "content": "А"
    },
    "result": null
  }
}
```

Через якийсь час перевіримо статус задачі

```http request
GET /articles/task/12345
```

Отримаємо rejected задачу, оскільки поле 'content' не пройшло валідацію.

```json5
{
  "data": {
    "id": "12345",
    "status": "rejected",
    "data": {
      "title": "New article",
      "content": "А"
    },
    "result": {
      "data": null,
      "messages": [
        {
          "type": "VALIDATION_ERROR",
          "level": "error",
          "text": "Content should contains at least 5 characters."
        }
      ]
    }
  }
}
```

Виправляємо content і повторюємо створення з тим самим ключем ідемпотентності

```http request
POST /articles/task
Content-Type: application/json
Accept: application/json

{
  "data": {
    "idempotency_key": "124",
    "data": {
      "title": "New article",
      "content": "My first article!"
    }
  }
}
```

На сервері вже зберігається одна задача з ідентифікатором 12345 і ключем ідемпотентності 124. Але оскільки вона має
статус rejected, то сервер створює ще одну задачу з цим самим ключем ідемпотентності 124, але іншим ідентифікатором.

```json5
{
  "data": {
    "id": "54321",
    "status": "pending",
    "data": {
      "title": "New article",
      "content": "My first article!"
    },
    "result": null
  }
}
```

Через деякий час перевіряємо її статус

```http request
GET /articles/task/54321
```

І отримуємо задачу зі статусом fulfilled у якої в результаті є ідентифікатор створеної статті.

```json5
{
  "data": {
    "id": "54321",
    "status": "fulfilled",
    "data": {
      "title": "New article",
      "content": "My first article!"
    },
    "result": {
      "data": {
        "article_id": '1'
      }
    }
  }
}
```

За допомогою ідентифікатора можем отримати повну інформацію про статтю

```http request
GET /articles/1
```

```json
{
  "data": {
    "id": 1,
    "title": "New article",
    "content": "My first article!",
    "created_at": "..."
  }
}
```

## Скасування задачі

Задача **МОЖЕ** мати можливість бути скасованою декількома способами.

1. Після закінчення таймауту (якщо такий був переданний).
2. Посилання http - запиту. Поки без деталей як саме, але при необхідності потрібно їх уточнити і додати в специфікацію.

Після скасування задача потрапляє у rejected статус.
